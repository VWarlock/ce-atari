#include <time.h>#include <mint/sysbind.h>#include <mint/osbind.h>#include <mint/basepage.h>#include <mint/ostruct.h>#include <unistd.h>#include <stdint.h>#include <stdio.h>#include <string.h>#include "acsi.h"/* ------------------------------------------ */
#define FALSE      0#define TRUE       1
/* ------------------------------------------ */#define BUFFER_SIZE		((MAXSECTORS + 2) * 512)
BYTE *buffOUT;BYTE *buffIN;
int WriteSector(DWORD Sector, BYTE count);int ReadSector(DWORD Sector, BYTE count, BYTE dontCheck);
void dumpBuffer(BYTE *buf, int offset);void dumpBufferShort(BYTE *buf, int length);void showMenu(void);
int inquiry(void);BYTE user_acsi_cmd(BYTE ReadNotWrite, BYTE *cmd, BYTE cmdLength, BYTE *buffer, WORD sectorCount);#define TEST_READ                   0x90#define TEST_WRITE                  0x91#define E_OK                        0#define E_CRC                       0xfc#define HOSTMOD_TRANSLATED_DISK     3#define CMD_LENGTH_SHORT    6#define CMD_LENGTH_LONG     13BYTE commandShort[CMD_LENGTH_SHORT]	= { 0 }; BYTE commandLong [CMD_LENGTH_LONG]	= {0x1f, 0xA0, 'C', 'E', HOSTMOD_TRANSLATED_DISK, 0, 0, 0, 0, 0, 0, 0, 0}; DWORD getTicks(void);BYTE acsiID, inquiryLength;void getCapacity(void);void showInt(int value, int length);void showHexByte(int val);void showHexWord(WORD val);void showHexDword(DWORD val);int writeHansTest( int byteCount, WORD xorVal );int readHansTest ( int byteCount, WORD xorVal );/* ------------------------------------------ */int main(void){	int i,j,k;	char c;
	DWORD scancode;    acsiID          = 0;    inquiryLength   = 50;    
	(void) Cconws("\33E");	/* ---------------------- */	buffOUT	= (BYTE *) Malloc(BUFFER_SIZE);	buffIN	= (BYTE *) Malloc(BUFFER_SIZE);	if(!buffOUT || !buffIN) {		(void) Cconws("Malloc() failed! :(\r\n");		Cnecin();		return 0;	}	/* ---------------------- */    showMenu();
	for(i=0; i<BUFFER_SIZE; i++)		buffOUT[i] = (BYTE) i;	while(1) {		scancode    = Cnecin();					/* get char form keyboard, no echo on screen */        c           = scancode & 0xff;		if(c >= 'A' && c <= 'Z') {			c = c + 32;					// to lower case		}				if(c == 'q') {		/* quit? */			break;		}                if(c == 'c') {      // get capacity?            getCapacity();        }                if(c == 'h') {            (void) Cconws("CE READ test: ");            j = readHansTest( 65536, 0 );                        if(j == 0) {                (void) Cconws("OK\r\n");            } else {                (void) Cconws("FAIL\r\n");            }        }                if(c == 'j') {            (void) Cconws("CE WRITE test: ");            j = writeHansTest( 65536, 0 );                        if(j == 0) {                (void) Cconws("OK\r\n");            } else {                (void) Cconws("FAIL\r\n");            }        }                if(c == 'd') {      // set ACSI ID?            (void) Cconws("\33EEnter new ACSI ID: ");            j = Cconin();            if(j >= '0' && j <= '9') {                i = j - '0';                j = 1;            } else {                j = 0;            }                        if(j == 1) {                acsiID = i;                (void) Cconws("New ACSI ID is: ");                Cconout(acsiID + '0');                (void) Cconws("\r\n");                                commandShort[0] = (acsiID << 5); 		        /* cmd[0] = ACSI_id + TEST UNIT READY (0)	*/                commandLong[0]  = (acsiID << 5) | 0x1f;			/* cmd[0] = ACSI_id + ICD command marker (0x1f)	*/            } else {                (void) Cconws("Failed to read ACSI ID, use only numbers.\r\n");            }                        Cnecin();            showMenu();        }                if(c == 'l') {            (void) Cconws("\33EEnter new INQUIRY response length: ");            j = Cconin();            if(j >= '0' && j <= '9') {                i = j - '0';                j = 1;            } else {                j = 0;            }                        if(j == 1) {                inquiryLength = i;                (void) Cconws("New INQUIRY response length is: ");                showInt(inquiryLength, -1);                (void) Cconws("\r\n");            } else {                (void) Cconws("Failed to get INQUIRY response length, use only numbers.\r\n");            }            Cnecin();            showMenu();        }		if(c == 'w') {		/* write? */
			j = WriteSector(0, 1);
			if(j != 0) {				(void) Cconws("Write error!\r\n");			} else {				(void) Cconws("Write OK.\r\n");			}
		}				if(c == 'r') {		/* read? */			j = ReadSector(0, 1, 0);			if(j != 0) {				(void) Cconws("Read error!\r\n");			} else {				(void) Cconws("Read OK.\r\n");			}		}				if(c == 'm') {		/* read 5? */			j = ReadSector(0, 5, 0);			if(j != 0) {				(void) Cconws("Read 5 error!\r\n");			} else {				(void) Cconws("Read 5 OK.\r\n");			}		}		if(c == 'n') {		/* write 5? */			j = WriteSector(0, 5);			if(j != 0) {				(void) Cconws("Write 5 error!\r\n");			} else {				(void) Cconws("Write 5 OK.\r\n");			}		}		if(c == 'i') {		/* inquiry? */			j = inquiry();			if(j != 0) {				(void) Cconws("Inquiry error!\r\n");			} else {				(void) Cconws("Inquiry OK.\r\n");			}		}				if(c == 'x') {			j = ReadSector(0, MAXSECTORS, 0);			if(j != 0) {				(void) Cconws("Read MAX SECTORS error!\r\n");			} else {				(void) Cconws("Read MAX SECTORS OK.\r\n");			}		}				if(c == 'y') {			DWORD start, end;						start = getTicks();			for(k=0; k<10; k++) {				j = ReadSector(0, MAXSECTORS, 1);				if(j != 0) {					break;				}			}						end = getTicks();						if(j != 0 ) {				(void) Cconws("Read 10x MAX SECTORS error!\r\n");			} else {				DWORD diff = end - start;                				int bps  = ((10 * MAXSECTORS * 512) / diff) * 200;				int kbps = bps / 1024;							(void)Cconws("Read 10x MAX SECTORS OK.\r\nIt took ");                showInt(diff, -1);                (void)Cconws(" ticks.\r\nEstimated speed is ");                showInt((int) kbps, -1);                (void)Cconws(" kB/s\r\n");			}		}	}			Mfree(buffOUT);	Mfree(buffIN);
	return 0;}void getCapacity(void){    int res;    BYTE cmd[11] = {0x1f, 0x25, 0, 0, 0, 0, 0, 0, 0, 0, 0};    res = user_acsi_cmd(1, cmd, 11, buffIN, 1);    if(res == 0) {        (void) Cconws("READ CAPACITY - GOOD\r\n\r");        (void)Cconws("Capacity: ");        showHexByte(buffIN[0]);        showHexByte(buffIN[1]);        showHexByte(buffIN[2]);        showHexByte(buffIN[3]);        (void)Cconws("\r\n");    } else {        (void) Cconws("READ CAPACITY - FAIL\r\n\r");    }}/* ------------------------------------------ */void showMenu(void){	(void) Cconws("\33E");	(void) Cconws("\33p >>> Destructive write-read verification <<< ");	(void) Cconws("\r\n >>>         2013 & 2014, by Jookie      <<< \33q\r\n");	(void) Cconws("\r\nQ = quit, R = read, W = write \r\n");	(void) Cconws("M = read 5, N = write 5, I = inquiry\r\n");	(void) Cconws("X = Read MAX SECTORS, Y = Read 10x MAX SECTORS\r\n");	(void) Cconws("D = set ACSI ID, L = set inquiry length\r\n");    (void) Cconws("C = read capacity\r\n");	(void) Cconws("H = CE test READ, J = CE test WRITE\r\n");}/* ------------------------------------------ */void formatCommand(BYTE *cmdBuffer, BYTE cmd, DWORD firstSector, BYTE sectorCount){	cmdBuffer[0] = (acsiID << 5) | (cmd & 0x1f);	cmdBuffer[1] = (BYTE) (firstSector >> 16);	cmdBuffer[2] = (BYTE) (firstSector >>  8);	cmdBuffer[3] = (BYTE) firstSector;	cmdBuffer[4] = sectorCount;	cmdBuffer[5] = 0;}/* ------------------------------------------ */int WriteSector(DWORD Sector, BYTE count){	int res;
	formatCommand(commandShort, SCSI_CMD_WRITE, Sector, count);	res = user_acsi_cmd(ACSI_WRITE, commandShort, CMD_LENGTH_SHORT, buffOUT, count);

	return res;}/* ------------------------------------------ */int ReadSector(DWORD Sector, BYTE count, BYTE dontCheck){	int res,i;	formatCommand(commandShort, SCSI_CMD_READ, Sector, count);	res = user_acsi_cmd(ACSI_READ, commandShort, CMD_LENGTH_SHORT, buffIN, count);
	if(res != 0)		return res;			if(dontCheck) {		return 0;	}
	for(i=0; i<(512 * count); i++) {		if(buffIN[i] != ((BYTE)i)) {			dumpBuffer(buffIN, i);					return -1;		}	}
	return 0;}/* ------------------------------------------ */int inquiry(void){	int res;	formatCommand(commandShort, SCSI_CMD_INQUIRY, 0, inquiryLength);	res = user_acsi_cmd(ACSI_READ, commandShort, CMD_LENGTH_SHORT, buffIN, 1);		if(res != 0)		return res;	(void) Cconws("\r\nINQUIRY:\r\n");	dumpBufferShort(buffIN, inquiryLength);	return 0;}/* ------------------------------------------ */void dumpBuffer(BYTE *buf, int offset){	int row, col, rowStart;	BYTE val;	int sector		= offset / 512;	int sectOffset	= sector * 512;		#define COLS	16	#define ROWS	(512 / COLS)	(void)Cconws("\r\nError on sector #");    showInt(sector, -1);    (void)Cconws(".\r\n");		for(row=0; row<ROWS; row++) {		if(row == (ROWS / 2)) {							/* in the middle wait for key */			(void) Cconws("Press a key to continue...\r\n");			Cconin();			(void) Cconws("\r\n");		}			rowStart = row * COLS;				for(col=0; col<COLS; col++) {			showHexByte(buf[sectOffset + rowStart + col]);            Cconout(' ');		}		for(col=0; col<COLS; col++) {			val = buf[sectOffset + rowStart + col];						if(val < 32 || val > 126) {				val = '.';			}						Cconout(val);		}				(void) Cconws("\r\n");	}}/* ------------------------------------------ */void dumpBufferShort(BYTE *buf, int length){	int row, col, rowStart, index;	BYTE val;	#define COLS	16	#define ROWS	(512 / COLS)	for(row=0; row<ROWS; row++) {		if((row % 20) == 0 && row != 0) {               // after 20 rows wait for a key (screen is 23 rows)			(void) Cconws("Press a key to continue...\r\n");			Cconin();			(void) Cconws("\r\n");		}			rowStart = row * COLS;				for(col=0; col<COLS; col++) {			index = rowStart + col;						if(index < length) {						/* going too far? pad with spaces */				showHexByte(buf[index]);                Cconout(' ');			} else {				(void) Cconws("   ");			}				}		for(col=0; col<COLS; col++) {			index = rowStart + col;						if(index >= length) {						/* going too far? stop! */				(void) Cconws("\r\n");							/* end line and quit */				return;			}			val = buf[index];						if(val < 32 || val > 126) {				val = '.';			}						Cconout(val);		}				(void) Cconws("\r\n");	}}/* ------------------------------------------ */
DWORD superGetTicks(void){	DWORD now;		now = *HZ_200;	return now;}DWORD getTicks(void){	return Supexec(superGetTicks);}/* ------------------------------------------ */BYTE gReadNotWrite;BYTE *gCmd;BYTE gCmdLength;BYTE *gBuffer;WORD gSectorCount;BYTE super_acsi_cmd(void){	return acsi_cmd(gReadNotWrite, gCmd, gCmdLength, gBuffer, gSectorCount);}BYTE user_acsi_cmd(BYTE ReadNotWrite, BYTE *cmd, BYTE cmdLength, BYTE *buffer, WORD sectorCount){	gReadNotWrite	= ReadNotWrite;	gCmd			= cmd;	gCmdLength		= cmdLength;	gBuffer			= buffer;	gSectorCount	= sectorCount;	return Supexec(super_acsi_cmd);}/* ------------------------------------------ */int readHansTest( int byteCount, WORD xorVal ){    WORD res;    	commandLong[4+1] = TEST_READ;  //size to read	commandLong[5+1] = (byteCount>>16)&0xFF;	commandLong[6+1] = (byteCount>>8)&0xFF;	commandLong[7+1] = (byteCount)&0xFF;  //Word to XOR with data on CE side	commandLong[8+1] = (xorVal>>8)&0xFF;	commandLong[9+1] = (xorVal)&0xFF;	res = user_acsi_cmd(ACSI_READ, commandLong, CMD_LENGTH_LONG, buffIN, (byteCount+511)>>9 );		// issue the command and check the result        if(res != OK) {                                                             // ACSI ERROR?        return -1;    }        int i;    WORD counter = 0;    WORD data = 0;    for(i=0; i<byteCount; i += 2) {        data = counter ^ xorVal;       // create word        if( !(buffIN[i]==(data>>8) && buffIN[i+1]==(data&0xFF)) ){          return -2;        }          counter++;    }    if(byteCount & 1) {                                 // odd number of bytes? add last byte        BYTE lastByte = (counter ^ xorVal) >> 8;        if( buffIN[byteCount-1]!=lastByte ){          return -2;        }      }    	return 0;}/*--------------------------------------------------*/int writeHansTest( int byteCount, WORD xorVal ){    BYTE res;    	commandLong[4+1] = TEST_WRITE;  //size to read	commandLong[5+1] = (byteCount>>16)&0xFF;	commandLong[6+1] = (byteCount>>8)&0xFF;	commandLong[7+1] = (byteCount)&0xFF;  //Word to XOR with data on CE side	commandLong[8+1] = (xorVal>>8)&0xFF;	commandLong[9+1] = (xorVal)&0xFF;    int i;    WORD counter = 0;    WORD data = 0;    for(i=0; i<byteCount; i += 2) {        data = counter ^ xorVal;       // create word        buffIN[i] = (data>>8);        buffIN[i+1] = (data&0xFF);        counter++;    }    if(byteCount & 1) {                                 // odd number of bytes? add last byte        BYTE lastByte = (counter ^ xorVal) >> 8;        buffIN[byteCount-1]=lastByte;    }	res = user_acsi_cmd(ACSI_WRITE, commandLong, CMD_LENGTH_LONG, buffIN, (byteCount+511)>>9 );		// issue the command and check the result        if(res == E_CRC) {                                                                    return -2;    }    if(res != E_OK) {                                                                     return -1;    }    	return 0;}/*--------------------------------------------------*/void showInt(int value, int length){    char tmp[10];    memset(tmp, 0, 10);    if(length == -1) {                      // determine length?        int i, div = 10;        for(i=1; i<6; i++) {                // try from 10 to 1000000            if((value / div) == 0) {        // after division the result is zero? we got the length                length = i;                break;            }            div = div * 10;                 // increase the divisor by 10        }        if(length == -1) {                  // length undetermined? use length 6            length = 6;        }    }    int i;    for(i=0; i<length; i++) {               // go through the int lenght and get the digits        int val, mod;        val = value / 10;        mod = value % 10;        tmp[length - 1 - i] = mod + 48;     // store the current digit        value = val;    }    (void) Cconws(tmp);                     // write it out}/*--------------------------------------------------*/void showHexByte(int val){    int hi, lo;    char tmp[3];    char table[16] = {"0123456789ABCDEF"};        hi = (val >> 4) & 0x0f;;    lo = (val     ) & 0x0f;    tmp[0] = table[hi];    tmp[1] = table[lo];    tmp[2] = 0;        (void) Cconws(tmp);}void showHexWord(WORD val){    BYTE a,b;    a = val >>  8;    b = val;        showHexByte(a);    showHexByte(b);}void showHexDword(DWORD val){    BYTE a,b,c,d;    a = val >> 24;    b = val >> 16;    c = val >>  8;    d = val;        showHexByte(a);    showHexByte(b);    showHexByte(c);    showHexByte(d);}/*--------------------------------------------------*/void *memcpy ( void * destination, const void * source, size_t num ){	BYTE *dst = (BYTE *) destination;	BYTE *src = (BYTE *) source;	int i;		for(i=0; i<num; i++) {				// copy all from src to dst		dst[i] = src[i];	}		return destination;}/*--------------------------------------------------*/
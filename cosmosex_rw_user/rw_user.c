#include <time.h>#include <mint/sysbind.h>#include <mint/osbind.h>#include <mint/basepage.h>#include <mint/ostruct.h>#include <unistd.h>#include <stdint.h>#include <stdio.h>#include <string.h>#include "acsi.h"/* ------------------------------------------ */
#define FALSE      0#define TRUE       1
/* ------------------------------------------ */#define BUFFER_SIZE		((MAXSECTORS + 2) * 512)
BYTE *buffOUT;BYTE *buffIN;
int WriteSector(DWORD Sector, BYTE count);int ReadSector(DWORD Sector, BYTE count, BYTE dontCheck);
void dumpBuffer(BYTE *buf, int offset);void dumpBufferShort(BYTE *buf, int length);void showMenu(void);
int inquiry(void);BYTE user_acsi_cmd(BYTE ReadNotWrite, BYTE *cmd, BYTE cmdLength, BYTE *buffer, WORD sectorCount);#define CMD_LENGTH_SHORT 6BYTE commandShort[CMD_LENGTH_SHORT]	= { 0 }; DWORD getTicks(void);BYTE acsiID, inquiryLength;void getCapacity(void);/* ------------------------------------------ */int main(void){	int i,j,k;	char c;
	DWORD scancode;    acsiID          = 0;    inquiryLength   = 50;    
	printf("%c%c",27,'E');		/* ---------------------- */	buffOUT	= (BYTE *) Malloc(BUFFER_SIZE);	buffIN	= (BYTE *) Malloc(BUFFER_SIZE);	if(!buffOUT || !buffIN) {		printf("Malloc() failed! :(\n");		Cnecin();		return 0;	}	/* ---------------------- */    showMenu();
	for(i=0; i<BUFFER_SIZE; i++)		buffOUT[i] = (BYTE) i;	while(1) {		scancode    = Cnecin();					/* get char form keyboard, no echo on screen */        c           = scancode & 0xff;		if(c >= 'A' && c <= 'Z') {			c = c + 32;					// to lower case		}				if(c == 'q') {		/* quit? */			break;		}                if(c == 'c') {      // get capacity?            getCapacity();        }                if(c == 'd') {      // set ACSI ID?            printf("%c%c",27,'E');            printf("Enter new ACSI ID: ");            j = scanf("%d", &i);                        if(j == 1) {                acsiID = i;                printf("New ACSI ID is: %d\n", acsiID);            } else {                printf("Failed to read ACSI ID, use only numbers.\n");            }                        Cnecin();            showMenu();        }                if(c == 'l') {            printf("%c%c",27,'E');            printf("Enter new INQUIRY response length: ");            j = scanf("%d", &i);                        if(j == 1) {                inquiryLength = i;                printf("New INQUIRY response length is: %d\n", inquiryLength);            } else {                printf("Failed to get INQUIRY response length, use only numbers.\n");            }            Cnecin();            showMenu();        }		if(c == 'w') {		/* write? */
			j = WriteSector(0, 1);
			if(j != 0) {				printf("Write error!\n");			} else {				printf("Write OK.\n");			}
		}				if(c == 'r') {		/* read? */			j = ReadSector(0, 1, 0);			if(j != 0) {				printf("Read error!\n");			} else {				printf("Read OK.\n");			}		}				if(c == 'm') {		/* read 5? */			j = ReadSector(0, 5, 0);			if(j != 0) {				printf("Read 5 error!\n");			} else {				printf("Read 5 OK.\n");			}		}		if(c == 'n') {		/* write 5? */			j = WriteSector(0, 5);			if(j != 0) {				printf("Write 5 error!\n");			} else {				printf("Write 5 OK.\n");			}		}		if(c == 'i') {		/* inquiry? */			j = inquiry();			if(j != 0) {				printf("Inquiry error!\n");			} else {				printf("Inquiry OK.\n");			}		}				if(c == 'x') {			j = ReadSector(0, MAXSECTORS, 0);			if(j != 0) {				printf("Read MAX SECTORS error!\n");			} else {				printf("Read MAX SECTORS OK.\n");			}		}				if(c == 'y') {			DWORD start, end;						start = getTicks();			for(k=0; k<10; k++) {				j = ReadSector(0, MAXSECTORS, 1);				if(j != 0) {					break;				}			}						end = getTicks();						if(j != 0 ) {				printf("Read 10x MAX SECTORS error!\n");			} else {				DWORD diff = end - start;				float secs = ((float) diff) / 200.0;				float bps  = ((float)(10 * MAXSECTORS * 512)) / secs;				float kbps = bps / 1024.0f;				float mbps = kbps / 1024.0f;							printf("Read 10x MAX SECTORS OK.\nIt took %d ticks, that's %.2f s.\nEstimated speed is %.1f kB/s (%.2f MB/s).\n", diff, secs, kbps, mbps);			}		}	}			Mfree(buffOUT);	Mfree(buffIN);
	return 0;}void getCapacity(void){    int res;    BYTE cmd[11] = {0x1f, 0x25, 0, 0, 0, 0, 0, 0, 0, 0, 0};    res = user_acsi_cmd(1, cmd, 11, buffIN, 1);    if(res == 0) {        (void) Cconws("READ CAPACITY - GOOD\n\r");        printf("Capacity: %02X%02X%02X%02X\n", (int) buffIN[0], (int) buffIN[1], (int) buffIN[2], (int) buffIN[3]);    } else {        (void) Cconws("READ CAPACITY - FAIL\n\r");    }}/* ------------------------------------------ */void showMenu(void){	printf("%c%c",27,'E');		printf("%c%c >>> Destructive write-read verification <<< ",27,'p');	printf  ("\n >>>         2013 & 2014, by Jookie      <<< %c%c\n", 27, 'q');	printf("\nQ = quit, R = read, W = write \n");	printf("M = read 5, N = write 5, I = inquiry\n");	printf("X = Read MAX SECTORS, Y = Read 10x MAX SECTORS\n");	printf("D = set ACSI ID, L = set inquiry length\n");    printf("C = read capacity\n");}/* ------------------------------------------ */void formatCommand(BYTE *cmdBuffer, BYTE cmd, DWORD firstSector, BYTE sectorCount){	cmdBuffer[0] = (acsiID << 5) | (cmd & 0x1f);	cmdBuffer[1] = (BYTE) (firstSector >> 16);	cmdBuffer[2] = (BYTE) (firstSector >>  8);	cmdBuffer[3] = (BYTE) firstSector;	cmdBuffer[4] = sectorCount;	cmdBuffer[5] = 0;}/* ------------------------------------------ */int WriteSector(DWORD Sector, BYTE count){	int res;
	formatCommand(commandShort, SCSI_CMD_WRITE, Sector, count);	res = user_acsi_cmd(ACSI_WRITE, commandShort, CMD_LENGTH_SHORT, buffOUT, count);

	return res;}/* ------------------------------------------ */int ReadSector(DWORD Sector, BYTE count, BYTE dontCheck){	int res,i;	formatCommand(commandShort, SCSI_CMD_READ, Sector, count);	res = user_acsi_cmd(ACSI_READ, commandShort, CMD_LENGTH_SHORT, buffIN, count);
	if(res != 0)		return res;			if(dontCheck) {		return 0;	}
	for(i=0; i<(512 * count); i++) {		if(buffIN[i] != ((BYTE)i)) {			dumpBuffer(buffIN, i);					return -1;		}	}
	return 0;}/* ------------------------------------------ */int inquiry(void){	int res;	formatCommand(commandShort, SCSI_CMD_INQUIRY, 0, inquiryLength);	res = user_acsi_cmd(ACSI_READ, commandShort, CMD_LENGTH_SHORT, buffIN, 1);		if(res != 0)		return res;	printf("\nINQUIRY:\n");	dumpBufferShort(buffIN, inquiryLength);	return 0;}/* ------------------------------------------ */void dumpBuffer(BYTE *buf, int offset){	int row, col, rowStart;	BYTE val;	int sector		= offset / 512;	int sectOffset	= sector * 512;		#define COLS	16	#define ROWS	(512 / COLS)	printf("\nError on sector #%d.\n", sector);		for(row=0; row<ROWS; row++) {		if(row == (ROWS / 2)) {							/* in the middle wait for key */			printf("Press a key to continue...\n");			Cconin();			printf("\n");		}			rowStart = row * COLS;				for(col=0; col<COLS; col++) {			printf("%02x ", buf[sectOffset + rowStart + col]);		}		for(col=0; col<COLS; col++) {			val = buf[sectOffset + rowStart + col];						if(val < 32 || val > 126) {				val = '.';			}						printf("%c", val);		}				printf("\n");	}}/* ------------------------------------------ */void dumpBufferShort(BYTE *buf, int length){	int row, col, rowStart, index;	BYTE val;	#define COLS	16	#define ROWS	(512 / COLS)	for(row=0; row<ROWS; row++) {		if((row % 20) == 0 && row != 0) {               // after 20 rows wait for a key (screen is 23 rows)			printf("Press a key to continue...\n");			Cconin();			printf("\n");		}			rowStart = row * COLS;				for(col=0; col<COLS; col++) {			index = rowStart + col;						if(index < length) {						/* going too far? pad with spaces */				printf("%02x ", buf[index]);			} else {				printf("   ");			}				}		for(col=0; col<COLS; col++) {			index = rowStart + col;						if(index >= length) {						/* going too far? stop! */				printf("\n");							/* end line and quit */				return;			}			val = buf[index];						if(val < 32 || val > 126) {				val = '.';			}						printf("%c", val);		}				printf("\n");	}}/* ------------------------------------------ */
DWORD superGetTicks(void){	DWORD now;		now = *HZ_200;	return now;}DWORD getTicks(void){	return Supexec(superGetTicks);}/* ------------------------------------------ */BYTE gReadNotWrite;BYTE *gCmd;BYTE gCmdLength;BYTE *gBuffer;WORD gSectorCount;BYTE super_acsi_cmd(void){	return acsi_cmd(gReadNotWrite, gCmd, gCmdLength, gBuffer, gSectorCount);}BYTE user_acsi_cmd(BYTE ReadNotWrite, BYTE *cmd, BYTE cmdLength, BYTE *buffer, WORD sectorCount){	gReadNotWrite	= ReadNotWrite;	gCmd			= cmd;	gCmdLength		= cmdLength;	gBuffer			= buffer;	gSectorCount	= sectorCount;	return Supexec(super_acsi_cmd);}/* ------------------------------------------ */